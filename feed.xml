<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>   
    <title>Raspberry Pie</title>
    <atom:link href="http://cellux.github.com/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://cellux.github.com</link>
    <description>My personal adventures in the world of the Raspberry Pi</description>
    <pubDate>Fri, 04 Jan 2013 22:58:00 +0100</pubDate>
    <generator>The mighty Wintersmith</generator>
    <language>en</language>
    <item>
      <title>Moving to NFS root</title>
      <link>http://cellux.github.com/articles/moving-to-nfs-root/</link>
      <pubDate>Fri, 04 Jan 2013 22:58:00 +0100</pubDate>
      <guid isPermaLink="true">http://cellux.github.com/articles/moving-to-nfs-root/</guid>
      <author></author>
      <description>&lt;p&gt;My first hack was to move the root filesystem from the SD card&apos;s second ext4 partition to a network-accessible directory shared by my router over NFS.

&lt;/p&gt;
&lt;p&gt;To understand how this hack fits into the grand scheme of things, I&apos;ll have to introduce you to my home network:

&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;home_network.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;On the image you see the following gear:

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the Pi (obviously)&lt;/li&gt;
&lt;li&gt;a Trust 7-port USB hub&lt;/li&gt;
&lt;li&gt;two external HDDs&lt;/li&gt;
&lt;li&gt;Huawei USB 3G modem&lt;/li&gt;
&lt;li&gt;HDMI switch&lt;/li&gt;
&lt;li&gt;HDMI TV&lt;/li&gt;
&lt;li&gt;XBox 360&lt;/li&gt;
&lt;li&gt;TP-Link WR842ND wireless router (with an extra USB port)&lt;/li&gt;
&lt;li&gt;Asus O!Play media player&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Pi draws its power from the Trust USB hub through a simple USB-microUSB cable. After reading a lot of bitter posts about power-related problems, I was quite afraid that this setup wouldn&apos;t work, but fortunately it does.

&lt;/p&gt;
&lt;p&gt;The TP-Link router was modded: I replaced the factory firmware with &lt;a href=&quot;https://openwrt.org/&quot;&gt;OpenWRT&lt;/a&gt;, a home-grown Linux distribution specially developed for Linux-based routers.

&lt;/p&gt;
&lt;p&gt;OpenWRT made it possible to share the NTFS filesystems on the two external USB harddrives over Samba (Windows file-sharing) and NFS to the home network, which means the Asus O!Play can now stream HD movies from any of the external disks (via a direct Ethernet connection to the router), and my son can watch his favorite Simpsons episodes from his bed on his Android phone (over WiFi). Internet is provided by the Huawei 3G modem connected to one of the Trust hub&apos;s USB ports.

&lt;/p&gt;
&lt;p&gt;In order to move the Pi&apos;s root filesystem over to NFS, I needed an ext4 partition which the router can access and share over the network. As the router is not too capable on the storage front (it has only 8 MB of flash memory), I had to create the ext4 filesystem on one of the external disks.

&lt;/p&gt;
&lt;p&gt;The only way I could do this - without reformatting the drives (remember, we are dealing with NTFS filesystems) - was to create a 8 GB file on one of the disks and then create the ext4 filesystem &lt;em&gt;inside&lt;/em&gt; that file:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;opkg install ntfs-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;g
mkdir -p /mnt/shares/samsung
mount -t ntfs-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;g /dev/sda1 /mnt/shares/samsung
dd &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;=/dev/zero of=/mnt/shares/samsung/rpifs.img bs=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;G count=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;
opkg install e2fsprogs
mkfs.ext4 -F /mnt/shares/samsung/rpifs.img
opkg install kmod-fs-ext4
opkg install kmod-loop losetup
mkdir -p /mnt/shares/rpifs
mount -t ext4 -o loop /mnt/shares/samsung/rpifs.img /mnt/shares/rpifs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(These were all executed on the router. I added the &lt;code&gt;opkg install&lt;/code&gt; commands to let you see which OpenWRT packages were required. Of course the mounts were later recorded into &lt;code&gt;/etc/config/fstab&lt;/code&gt; for auto-mounting.)

&lt;/p&gt;
&lt;p&gt;While this setup is rather complicated and slow, it works. Ideally, the external disks would form a RAID1 cluster (provided by a NAS device like &lt;a href=&quot;http://www.fantec.de/html/en/2/artId/__1515/gid/__500905309053790537290/article.html&quot;&gt;this&lt;/a&gt;), and the RAID volume would be formatted with ext4 (which is &lt;em&gt;much&lt;/em&gt; faster than &lt;code&gt;ntfs-3g&lt;/code&gt; on Linux).

&lt;/p&gt;
&lt;p&gt;The next step was to create a suitable root filesystem on &lt;code&gt;/mnt/shares/rpifs&lt;/code&gt;. At first, I just used the files from the default Raspbian installation:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;mkdir /tmp/raspbian
mount -t ext4 -o loop,offset=$((122880*512)) 2012-12-16-wheezy-raspbian.img /tmp/raspbian/
rsync -av /tmp/raspbian/ /mnt/shares/rpifs/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This crazy &lt;code&gt;mount&lt;/code&gt; (or rather &lt;code&gt;losetup&lt;/code&gt;) trick allows you to mount a &lt;em&gt;part&lt;/em&gt; of a disk image - like one of the partitions inside - via a loop device. To make it work, you have to find out where the desired partition starts (byte offset from start of image file) and pass that to mount via the &lt;code&gt;offset&lt;/code&gt; option. You can use &lt;code&gt;fdisk&lt;/code&gt; to find the right number:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;[rb@pluto 2012-12-16-wheezy-raspbian]$ fdisk -l 2012-12-16-wheezy-raspbian.img 

Disk 2012-12-16-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00017b69

                         Device Boot      Start         End      Blocks   Id  System
2012-12-16-wheezy-raspbian.img1            8192      122879       57344    c  W95 FAT32 (LBA)
2012-12-16-wheezy-raspbian.img2          122880     3788799     1832960   83  Linux&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the FAT32 partition (&lt;code&gt;/boot&lt;/code&gt;) comes first, starting at sector #8192, then comes the ext4 fs (&lt;code&gt;/&lt;/code&gt;) at sector #122880. As each sector uses 512 bytes, we&apos;ll have to multiply the sector number by 512 to get the byte offset.

&lt;/p&gt;
&lt;p&gt;The only thing left was telling the Pi Linux kernel that it should mount its root fs from the router over NFS, instead of locally from the SD card.

&lt;/p&gt;
&lt;p&gt;As I wrote in the &lt;a href=&quot;http://cellux.github.com/articles/my-first-day-with-the-raspberry-pi/&quot;&gt;previous&lt;/a&gt; post, the Linux kernel gets its command line from the file &lt;code&gt;cmdline.txt&lt;/code&gt; on the &lt;code&gt;/boot&lt;/code&gt; partition (first FAT32 partition of the SD card).

&lt;/p&gt;
&lt;p&gt;In the Raspbian image which I downloaded, this file has the following contents (also verifiable with the offset mount trick):

&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This had to be changed like this:

&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/nfs nfsroot=192.168.1.1:/mnt/shares/rpifs ip=dhcp elevator=deadline rootwait&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;root=/dev/nfs&lt;/code&gt; option tells the kernel that the root filesystem is on NFS&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;ip=dhcp&lt;/code&gt; option makes the kernel configure the primary network interface (eth0) via DHCP (this is a prerequisite for an NFS mount)&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;nfsroot=192.168.1.1:/mnt/shares/rpifs&lt;/code&gt; defines the location of the root file system&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, the &lt;code&gt;/mnt/shares/rpifs&lt;/code&gt; directory had to be shared on the router as well:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;opkg install portmap nfs-kernel-server nfs-kernel-server-utils
&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;'/mnt/shares/rpifs 192.168.1.0/24(rw,no_root_squash,insecure,no_subtree_check,mp)'&lt;/span&gt; &gt;&gt; /etc/exports
/etc/init.d/nfsd enable
/etc/init.d/nfsd start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the NFS server was up, I verified that the share can be in fact mounted by entering the following commands on my netbook:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;mkdir /tmp/rpifs
mount -t nfs 192.168.1.1:/mnt/shares/rpifs /tmp/rpifs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then I updated &lt;code&gt;cmdline.txt&lt;/code&gt; as described above, restarted the Pi and voil√†, the root fs came up over NFS.
&lt;/p&gt;
</description>
    </item>
    <item>
      <title>My first day with the Raspberry Pi</title>
      <link>http://cellux.github.com/articles/my-first-day-with-the-raspberry-pi/</link>
      <pubDate>Thu, 03 Jan 2013 22:25:00 +0100</pubDate>
      <guid isPermaLink="true">http://cellux.github.com/articles/my-first-day-with-the-raspberry-pi/</guid>
      <author></author>
      <description>&lt;p&gt;At the end of 2012 - just a day or two before Christmas - I got my own Raspberry Pi from RS Components. 

&lt;/p&gt;
&lt;p&gt;The first thing I did was building a LEGO case for it:

&lt;/p&gt;
&lt;p id=&quot;gallery1&quot; class=&quot;gallery&quot; style=&quot;height: 480px&quot;&gt;
  &lt;img src=&quot;img_7054.jpg&quot;/&gt;
  &lt;img src=&quot;img_7061.jpg&quot;/&gt;
&lt;/p&gt;

&lt;p&gt;It&apos;s not a top engineering feat for sure, but the spaceman is kinda cool. :-)

&lt;/p&gt;
&lt;p&gt;For those of you who don&apos;t know what a Raspberry Pi is: it&apos;s a credit-card sized mini-computer developed by a bunch of elite computer geeks who call themselves the &lt;a href=&quot;http://www.raspberrypi.org/about&quot;&gt;Raspberry Pi Foundation&lt;/a&gt;. It looks like this:

&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img_7073.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;It has an SD card reader, two USB 2.0 ports, a 10/100 Ethernet port, a HDMI connector, an RCA video out, a 3.5 mm audio jack and a bunch of programmable pins which can be used to interface it with other devices. It can be powered through a micro USB port, using any cell phone charger which can supply the steady 5V and 700 mA it needs.

&lt;/p&gt;
&lt;p&gt;The heart of the machine is this SoC (System on a Chip) in the center of the board:

&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img_7076.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;This small chip contains an ARM 1176JZF-S CPU, a Broadcom VideoCore IV GPU and 512 MB RAM (these are the specs for my Model B - there is also a Model A with only 256 MB RAM, one USB port and no Ethernet).

&lt;/p&gt;
&lt;p&gt;To minimize the cost, there is no on/off button or reset switch: the only way to reset the system is to pull the plug and insert it again.

&lt;/p&gt;
&lt;h5&gt;The boot process&lt;/h5&gt;
&lt;p&gt;At startup, the VideoCore IV GPU gets control and initiates the boot process which consists of the following steps:

&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The GPU executes the first stage bootloader which is stored in ROM&lt;/li&gt;
&lt;li&gt;The first stage bootloader looks for a FAT32 partition on the SD card (this must be the first partition of the possible four) and loads the second stage boot loader from the file &lt;code&gt;bootcode.bin&lt;/code&gt; into the L2 cache&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bootcode.bin&lt;/code&gt; initializes the 512 MB SDRAM in the SoC, and loads the third stage loader from &lt;code&gt;start.elf&lt;/code&gt; into main memory (this binary contains the GPU firmware as well)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start.elf&lt;/code&gt; reads the file &lt;code&gt;config.txt&lt;/code&gt; and configures the system accordingly&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start.elf&lt;/code&gt; reads a kernel command line from &lt;code&gt;cmdline.txt&lt;/code&gt; and a kernel image from &lt;code&gt;kernel.img&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the GPU passes control to the ARM CPU which starts executing the kernel&lt;/li&gt;
&lt;li&gt;the kernel mounts a root partition from somewhere (typically from the second partition of the SD card), and runs &lt;code&gt;/sbin/init&lt;/code&gt; as usual&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On my first day, I just wanted to make sure that everything works as it should, so I downloaded a pre-built Linux distribution image from the foundation&apos;s website - which contains both the FAT32 partion mentioned above, plus an ext4 filesystem on the second partition serving as the root fs for Linux - and copied it to the SD card:

&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//downloads.raspberrypi.org/images/raspbian/2012-12-16-wheezy-raspbian/2012-12-16-wheezy-raspbian.zip&lt;/span&gt;
unzip &lt;span class=&quot;number&quot;&gt;2012&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;-wheezy-raspbian.zip
cat &lt;span class=&quot;number&quot;&gt;2012&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;-wheezy-raspbian.img &gt; /dev/sdb&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(As you see, the SD card was seen as &lt;code&gt;/dev/sdb&lt;/code&gt; by my Linux netbook.)

&lt;/p&gt;
&lt;p&gt;After the image had been written to the card, I removed it from the netbook, inserted it into the SD card slot on the Raspberry Pi, connected the HDMI cable to my TV, powered on the gizmo and watched the messages of the kernel - and later Raspbian - fly by, finally followed by a login prompt.

&lt;/p&gt;
&lt;p&gt;Success!
&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>